priority -49
###########################################################################
#          Global functions               #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
  args = str(arglist).split(',')

  if len(args) > 1:
    c = 0
    for arg in args:
      if c == 0:
        snip.rv += arg
        c = 1
      else:
        snip += '*       : %s' % arg.strip()
  else:
    snip.rv = args[0]


endglobal

###########################################################################
#                            TextMate Snippets                            #
#
##########################################################################

snippet main "main(int, char**) (main)"
int main(int argc, char *argv[]) {
  ${VISUAL}$0
}
endsnippet

snippet mainv "main(void) (main)"
int main() {
  ${VISUAL}$0
}
endsnippet

snippet inc "include"
#include <${1}>
endsnippet

snippet Inc "#include current file"
#include "${1:`vim_snippets#Filename("$1.h")`}"
endsnippet

## if statements

snippet if
if (${1:true}) {
  ${0:${VISUAL}}
}
endsnippet

snippet ife
if (${1:true}) {
  ${2:${VISUAL}}
} else {
  ${0}
}
endsnippet

snippet el "else"
else {
  ${0:${VISUAL}}
}
endsnippet

snippet elif "else if"
else if (${1:true}) {
  ${0:${VISUAL}}
}
endsnippet

snippet ifi "if inline"
if (${1:true}) ${0};
endsnippet


## loops
snippet while "while"
while (${1:true}) {
  ${0:${VISUAL}}
}
endsnippet

snippet forc "const range for loop (for)"
for (const auto& ${1:i} : ${2:container}) {
  ${VISUAL}$0
}
endsnippet

snippet for "range for loop"
for (auto& ${1:i} : ${2:container}) {
  ${VISUAL}$0
}
endsnippet

snippet fori "for int loop"
for (${4:int} ${2:i} = 0; $2 < ${1:count}; ${3:++$2}) {
  ${VISUAL}$0
}
endsnippet

snippet foro "old for loop"
for (${1}; ${2}; ${3}) {
  ${VISUAL}$0
}
endsnippet


## functions
snippet fun "function" b
${1:void} ${2:function_name}($3)
{
  ${VISUAL}$0
}
endsnippet

snippet fun0 "function with 0 params"
${1:void} ${2:function_name}() {
  ${VISUAL}$0
}
endsnippet

snippet fun1 "function with 1 params"
${1:void} ${2:function_name}(${3:Type} ${4:Parameter}) {
  ${VISUAL}$0
}
endsnippet

snippet fun2 "function with 2 params"
${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}) {
  ${VISUAL}$0
}
endsnippet

snippet fun3 "function with 3 params"
${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter}) {
  ${VISUAL}$0
}
endsnippet

snippet ld "single line lambda"
[${1}] (${2}) {${3}}
endsnippet

snippet lld "multi line lambda"
[${1}] (${2}) {
  ${VISUAL}$0
}
endsnippet


## classes
snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
  ${1/(\w+).*/$1/} (${2:arguments});
  virtual ~${1/(\w+).*/$1/} ();

private:
  ${0:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`} {
${VISUAL}$0
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet


## Access Modifiers
snippet pri "private"
private
endsnippet
snippet pro "protected"
protected
endsnippet
snippet pub "public"
public
endsnippet
snippet fr "friend"
friend
endsnippet
snippet mu "mutable"
mutable
endsnippet


## basic types
snippet car "const auto&"
const auto& ${1}
endsnippet
snippet ca "const auto"
const auto ${1}
endsnippet
snippet ar "auto&"
auto& ${1}
endsnippet
snippet a "auto"
auto ${1}
endsnippet
snippet c "const"
const ${1}
endsnippet


## Types
snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:char}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet ret
return ${0};
endsnippet

snippet array
std::array<${1:T}, ${2:N}> ${3};
endsnippet
# std::vector
snippet vector
std::vector<${1:T}> ${2};
endsnippet
# std::deque
snippet deque
std::deque<${1:T}> ${2};
endsnippet
# std::forward_list
snippet flist
std::forward_list<${1:T}> ${2};
endsnippet
# std::list
snippet list
std::list<${1:T}> ${2};
endsnippet
# std::set
snippet set
std::set<${1:T}> ${2};
endsnippet
# std::map
snippet map
std::map<${1:Key}, ${2:T}> ${3};
endsnippet
# std::multiset
snippet mset
std::multiset<${1:T}> ${2};
endsnippet
# std::multimap
snippet mmap
std::multimap<${1:Key}, ${2:T}> ${3};
endsnippet
# std::unordered_set
snippet uset
std::unordered_set<${1:T}> ${2};
endsnippet
# std::unordered_map
snippet umap
std::unordered_map<${1:Key}, ${2:T}> ${3};
endsnippet
# std::unordered_multiset
snippet umset
std::unordered_multiset<${1:T}> ${2};
endsnippet
# std::unordered_multimap
snippet ummap
std::unordered_multimap<${1:Key}, ${2:T}> ${3};
endsnippet
# std::stack
snippet stack
std::stack<${1:T}> ${2};
endsnippet
# std::queue
snippet queue
std::queue<${1:T}> ${2};
endsnippet
# std::priority_queue
snippet pqueue
std::priority_queue<${1:T}> ${2};
endsnippet


## Input/Output
# std::cout
snippet cout
std::cout << ${1} << '\n';
endsnippet

snippet cin
if (!(std::cin >> ${1}))
  throw std::invalid_argument("${2}");
endsnippet


## Casts
snippet sca "static cast"
static_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
# dynamic
snippet dca "dynamic cast"
dynamic_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
# reinterpret
snippet rca "reinterpret cast"
reinterpret_cast<${1:unsigned}>(${2:expr})${3}
endsnippet


## Misc
snippet beg "$1.begin(), $1.end()"
${1}.begin(), ${1}.end()
endsnippet

snippet cbeg "$1.cbegin(), $1.cend()"
${1}.cbegin(), ${1}.cend()
endsnippet

snippet try
try {
  ${VISUAL}$0
} catch(${1}) {
}
endsnippet

# vim:ft=snippets:
